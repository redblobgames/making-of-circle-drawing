#+title: Making of: Circle drawing tutorial
#+date: <2022-11-28 Mon>
#+vue: t

People ask me how I write my interactive tutorials. The first few years, I used d3.js, and I wrote [[href:/making-of/line-drawing/][an interactive tutorial about how I made interactive tutorials]]. I now use Vue.js v2, so I'm writing a new interactive tutorial about how I make interactive tutorials with Vue. On this page I'll recreate the first few diagrams of my [[href:/grids/circle-drawing/][circle drawing tutorial]], using [[https://v3.vuejs.org/][Vue.js v2]]. The ideas here will be similar if you use Vue v3 or React or Preact or Lit or Svelte etc.

#+begin_export html
<figure>
{ TODO: diagram showing the final result }
</figure>
#+end_export

* Web page
:PROPERTIES:
:CUSTOM_ID: web-page
:END:

I usually start with a basic web page template that includes scripts, footers, and one blank SVG diagram:

#+begin_export html
<figure>
  <a-output step="1" />
  <a-step step="1" />
</figure>
#+end_export

I attach an ~id=~ to an html element so that I can get to it from Javascript. Sometimes I'll attach it to the ~<svg>~ and sometimes to a ~<div>~ or ~<figure>~ outside the svg. For this page, I want interactive elements outside the svg so I'm putting the id on the ~<figure>~.

I'll omit the header and footer from the rest of the examples. Click the filename on the upper right to see the entire page up to that point. Using a ~viewBox~ on ~<svg>~ tells it the coordinate system to for drawing. We can use that to keep a consistent coordinate system even if the diagram is resized.

* Diagram
:PROPERTIES:
:CUSTOM_ID: diagram
:END:

Sometimes I'll add a diagram first and then add some text; other times I'll start with the text and then figure out the diagrams. For this page I'll start with a diagram.

The tutorial is about drawing circles on a square grid, so I need to draw a grid and also draw circles. I'll draw a grid with SVG. I start by making /one/ grid cell. I can write out the SVG for it:

#+begin_export html
<figure>
  <a-output step="2" />
  <a-step restrict="&lt;figure" step="2" />
</figure>
#+end_export

That's plain HTML+SVG. I could've created that SVG with an interactive editor but in this case I wrote it by hand. But I want /many/ grid cells. This is where the coding comes in. I want to repeat it, varying the position each time:

#+begin_export html
<figure>
  <a-output step="3" />
  <a-step restrict="&lt;figure" step="3" />
  <a-step show="js" step="3" />
</figure>
#+end_export

How does this work? In Vue, ~v-for~ means to repeat an element. In this case, it will create the =<rect>= for each element in =positions=. I make an array =positions= that contains all the x,y values I want on the grid, and then Vue will make one =<rect>= for each. The ~:x=~ syntax means it's setting the =x= attribute, but will compute it using a Javascript expression like =x * scale=.

In React, I'd use ~positions.map(…)~ to make an array of =<rect>=. In Svelte I'd use ~#{each … in positions}~. In Lit I'd use ~${repeat(positions, …)}~. These libraries have a way to loop over arrays, but they differ in the details. I'm showing Vue on this page but the concepts are similar across these libraries.

Those of you who know SVG might choose to use =viewBox= or =transform= to change the coordinate system to place points at the center of each grid square instead of at the top left, and also to scale things so that each grid square is 1 unit across instead of =scale= pixels. I did this in the original article but I didn't for this tutorial.

* Detail: negative space
:PROPERTIES:
:CUSTOM_ID: detail-negative-space
:END:

While working on a page, I'll sometimes work on the details during the process and sometimes towards the end. On this page I'll work on them during the process. For the grid, I sometimes use [[href:/making-of/little-things/#negative-space][negative space]]. Instead of drawing the grid lines, I'll draw grid interiors slightly smaller, in a color other than the background. The gaps serve as the edges:

#+begin_export html
<figure>
  <a-output step="4" />
  <a-step restrict="&lt;figure" step="4" />
</figure>
#+end_export

I don't do this for all pages. I use this on the A* pages, where the attention should be on the paths, but not on the hexagon pages, where the attention should be on the grid itself. Sometimes the color scheme doesn't allow for it.

* Algorithm
:PROPERTIES:
:CUSTOM_ID: algorithm
:END:

The most obvious thing to do with an interactive diagram is to run the algorithm and display the results. In this case, the first algorithm I present [[href:/grids/circle-drawing/#distance-test][on the page]] is a distance test in C++:

#+begin_src cpp
bool inside_circle(Point center, Point tile, float radius) {
    float dx = center.x - tile.x,
          dy = center.y - tile.y;
    float distance = sqrt(dx*dx + dy*dy);
    return distance <= radius;
}

for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
        if (inside_circle(center, Point(x, y), radius)) {
            // do something with (x, y)
        }
    }
}
#+end_src

This returns a =bool= for each tile. In the diagram, I can use a /color/ to show that boolean value.

#+begin_export html
<figure>
  <a-output step="5" />
</figure>
#+end_export

But the sample code is C++ and the diagram code is JavaScript, so I have to decide what to do here. I could compile the C++ to WASM so that I can directly call it from JavaScript, but in this case it is easier to reimplement it. The next question is /where/ should it go. I could either call =insideCircle= and then choose the color in the HTML, or I could have the HTML call =tileColor= and have that function select the color in JavaScript. I decided to select the color in the HTML. In Vue, a function has to be exported to make it available in the HTML template, but that detail will vary in React, Svelte, etc. 

#+begin_export html
<figure>
  <a-step restrict="&lt;figure" step="5" />
</figure>
#+end_export

I also need to decide where to store the circle center and radius. I decided to put those into the Vue =data=, which stores the state for that diagram. I will later want to make these interactive.

#+begin_export html
<figure>
  <a-step show="js" restrict="function insideCircle|new Vue" step="5" />
</figure>
#+end_export

One thing to note is that /I didn't implement the entire algorithm/. The full algorithm has a loop over tiles, and then runs the test for each tile, and collects the results. But in the diagram, the loop is implicit. I don't actually need to collect the results.

*This happens a lot*. The code for the /diagram/ is not the same as the original algorithm. The point of the diagram is help the /reader/ understand the concepts. It's not to demonstrate that /I/ know how to implement the algorithm. For example, in [[https://betterexplained.com/articles/quadratic-formula/][this article about the quadratic formula]], it would be easy to run the quadratic formula and give the answer. But the diagrams do something quite different, showing how completing a square relates to the quadratic formula.

* Interaction
:PROPERTIES:
:CUSTOM_ID: interaction
:END:

The diagram is now showing the /output/ of the algorithm, but it's not yet interactive. The obvious thing to do is to allow the reader to change the /inputs/. In this case the inputs are the center and radius of the circle. Let's add sliders to control those three numbers:

#+begin_export html
<figure>
  <a-output step="6" />
</figure>
#+end_export

In Vue, React, etc. the "source of truth" is a JavaScript value, and the HTML element displays/edits it. I need two parts, setting the slider /from/ a  JavaScript variable, and updating the JavaScript variable /from/ the slider when it's moved. In Vue, ~v-model~ is a shorthand syntax for setting both of those steps. In Svelte, ~bind:value~ is the shorthand syntax. In React and Lit, I can write the two parts separately. I'm using ~v-model.number~ to tell Vue that I want the value to be a number instead of a string:

#+begin_export html
<figure>
  <a-step restrict="&lt;label" step="6" />
</figure>
#+end_export

With the radius, I have /two/ =<input>= elements, both set to the same variable. That way I can edit either way (as a slider or an input box).

Editable variables need to be exported in Vue's =data= section, but I already had them there so I didn't have to change the HTML in this step.

* Detail: direct manipulation
:PROPERTIES:
:CUSTOM_ID: interaction-manipulation
:END:

Sliders are easy to implement, since the browser already supports ~<input type=range>~. When editing a geometric parameter like /position/, it's often better to directly manipulate the position by dragging it than to indirectly manipulate it by using a slider.

The bad news: this is where things get trickier. The good news: once I figured this part out, I reused it across lots of projects. I'm going to start with the simpler implementation, but there are [[href:/making-of/little-things/#interactivity][many more details that can be added]].

The first thing to do is add a /handle/. This is an object that represents the underlying variable, and is something the reader can drag around. The circle center is in /grid/ coordinates, and I need to turn them into /diagram/ coordinates. To do that, I add =1/2= so that the circle is centered inside a tile, then multiply by =scale=.

#+begin_export html
<figure>
  <a-output step="7" />
  <a-step step="7" restrict="&lt;circle"/>
</figure>
#+end_export

So far it's in the SVG but there's no behavior. Let's add some behavior to it:

#+begin_export html
<figure>
  <a-output step="8" />
  <a-step step="8" restrict="&lt;circle"/>
</figure>
#+end_export

Here's where it gets tricky. To go from the =center= in grid coordinates to a position in the diagram, I added =1/2= and then multiplied by =scale=. But that's in SVG coordinates. The browser then changed the SVG coordinates into screen coordinates. Here the =event= comes to us in screen coordinates. I need to reverse that:

1. Convert screen coordinates to SVG coordinates, using a helper function.
2. Convert SVG coordinates to grid coordinates: I divide by =scale= and then subtract =1/2=.

For the first, I use a helper function. It's useful across projects.

#+begin_export html
<figure>
  <a-step step="8" show="js" restrict="function convertPixelToSvgCoord" />
</figure>
#+end_export

For the second, I used this event handler, which gets called by ~@pointermove="moveCenter"~:

#+begin_export html
<figure>
  <a-step step="8" show="js" restrict="moveCenter" />
</figure>
#+end_export

This kind of two-way mapping from data to diagram and back is common, and I occasionally go overboard and [[href:articles/curved-paths/making-of.html][write a library to handle it]]. But in most cases I write it manually.

{ detail: drag a marker instead of setting x,y }

{ detail: drag a marker instead of setting the radius }

{ refactor: draggable markers }

{ making a second diagram with cut/paste of the html, almost change in javascript }

{ display distances }

{ add <figure> caption, and make it interactive }

#+begin_export html
<style>
  iframe { 
    width: 100%; 
    border: 0;
    margin: 0;
    padding: 0;
    box-shadow: 0 0.5px 3px 1px rgba(0, 0, 0, 0.3);
  }
    
  pre { line-height: 1.25em; }

  /* Prism */
  .language-html, .language-javascript { font-size: 1rem; }

  /* Prism html, purple theme */
  .token.punctuation { color: #a0a090; font-weight: normal; }
  .token.doctype-tag, .token.tag { color: hsl(0, 0%, 30%); font-weight: bold; }
  .token.name, .token.attr-name { color: hsl(300, 30%, 50%); }
  .token.attr-value { color: hsl(300, 10%, 50%); font-weight: normal; }

  /* Prism javascript, blue theme, but also trying to make it match my emacs-htmlize.scss */
  .token.keyword { color: hsl(220, 20%, 50%); font-weight: bold; }
  .token.function { color: #268bd2; }
  .token.keyword + .token.function { font-weight: bold; }
  .token.number { color: #888888; }
  .token.string { color: #888888; }
  .src .variable-name { color: hsl(200, 20%, 30%); font-weight: normal; }

  /* Prism javascript in html, for Vue, should be blue */
  .value.language-javascript, .value.language-javascript .token { color: hsl(200, 30%, 50%); font-weight: normal; font-style: italic; }
  .value.language-javascript .token.punctuation { color: hsl(200, 30%, 30%); }

  /* Prism diffs */
  .prefix.deleted { color: hsl(0, 50%, 50%); background: hsl(0, 30%, 90%); }
  .prefix.inserted { color: hsl(180, 50%, 50%); background: hsl(180, 30%, 90%); }
</style>

<x:footer>
  <script type="module" src="making-of-circle-drawing.js"></script>
  Created 28 Nov 2022 
  with <a href="https://v2.vuejs.org/">Vue.js</a> 
  and <a href="https://prismjs.com/">Prism.js</a> 
  and <a href="https://www.npmjs.com/package/diff-sequences">Diff-Sequences</a>
  ; &#160;
  <!-- hhmts start -->Last modified: 18 Dec 2022<!-- hhmts end -->
</x:footer>
#+end_export
